import java.text.SimpleDateFormat
import java.util.Calendar

def getSqlFolderPath(frequency: String, bteqLocation: String): String = {
  val dayOfWeek = new SimpleDateFormat("EEEE").format(Calendar.getInstance().getTime).toUpperCase

  val expectedFolder = frequency.toLowerCase match {
    case "d" => "DAILY"
    case "w" => dayOfWeek match {
      case "MONDAY"    => "MON"
      case "TUESDAY"   => "TUE"
      case "WEDNESDAY" => "WED"
      case "THURSDAY"  => "THU"
      case "FRIDAY"    => "FRI"
      case "SATURDAY"  => "SAT"
      case "SUNDAY"    => "SUN"
      case _           => throw new Exception(s"Invalid day: $dayOfWeek")
    }
    case "m" => "MONTHLY"
    case "q" => "QUARTERLY"
    case _   => throw new Exception(s"Unknown frequency: $frequency")
  }

  val folderPath = s"$bteqLocation/$expectedFolder"

  // STRICT CHECK: If trying to run Monday's files on Tuesday, stop execution
  if (frequency.toLowerCase == "w" && !folderPath.contains(dayOfWeek.substring(0, 3).toUpperCase)) {
    throw new Exception(s"ERROR: Cannot run $expectedFolder alerts today ($dayOfWeek). Expected: $expectedFolder folder.")
  }

  folderPath
}





// Join with df2 to get frequency
val processedAlertsWithFrequencyDF = processedAlertsDF
  .join(df2.select("alert_code", "frequency"), Seq("alert_code"), "left") // Left join to get frequency

// Define cutoff times for different frequencies
val processedBeforeCutoffDF = processedAlertsWithFrequencyDF
  .withColumn("cutoff_time",
    when(col("frequency") === "d", lit("13:05:00")) // Daily cutoff 1:05 PM
    .when(col("frequency") === "w", lit("16:05:00")) // Weekly cutoff 4:05 PM
    .otherwise(lit("16:05:00")) // Default (Monthly) cutoff 4:05 PM
  )
  .filter(col("check_datetime_aest") < col("cutoff_time")) // Filter alerts processed before cutoff


// Extract processed alert codes before cutoff time
val processedBeforeCutoff = processedBeforeCutoffDF
  .select("alert_code")
  .map(_.getString(0))
  .toSet

val combinedReceivedAlerts = receivedAcc.value.toSet ++ processedBeforeCutoff ++ alertsWithIssues




import java.util.{Calendar, TimeZone}

val aestZone = TimeZone.getTimeZone("Australia/Sydney")
val calNow = Calendar.getInstance(aestZone)
val currentHour = calNow.get(Calendar.HOUR_OF_DAY)
val currentMin = calNow.get(Calendar.MINUTE)

def sendMissedAlertsEmail(): Unit = {
    println("📩 Sending missed alerts email at 4:05 PM...")
    // Add logic to send missed alerts email
}

def sendConsolidatedEmail(): Unit = {
    println("📊 Sending consolidated email at 8:05 PM...")
    // Add logic to send consolidated email
}

def waitForTargetTime(targetHour: Int, targetMin: Int): Unit = {
    val targetCal = Calendar.getInstance(aestZone)
    targetCal.set(Calendar.HOUR_OF_DAY, targetHour)
    targetCal.set(Calendar.MINUTE, targetMin)
    targetCal.set(Calendar.SECOND, 0)
    targetCal.set(Calendar.MILLISECOND, 0)

    val nowMillis = System.currentTimeMillis()
    val targetMillis = targetCal.getTimeInMillis

    if (nowMillis < targetMillis) {
        val waitMillis = targetMillis - nowMillis
        println(s"⏳ Waiting for ${(waitMillis / 1000)} seconds until $targetHour:$targetMin AEST...")
        Thread.sleep(waitMillis)
    }
}

// **✅ Handle 4:05 PM missed alerts**
if (currentHour == 16 && currentMin >= 5 && currentMin < 10) {
    sendMissedAlertsEmail() // Process missed alerts immediately
} else if (currentHour == 16 && currentMin < 5) {
    waitForTargetTime(16, 5)
    sendMissedAlertsEmail()
}

// **✅ Handle 8:05 PM consolidated email**
else if (currentHour == 20 && currentMin >= 5 && currentMin < 10) {
    sendConsolidatedEmail() // Send consolidated email immediately
} else if (currentHour == 20 && currentMin < 5) {
    waitForTargetTime(20, 5)
    sendConsolidatedEmail()
}

// **✅ Run normal processing if not 4:05 PM or 8:05 PM**
else {
    println("⚡ Running other tasks as usual...")
    // Add normal data processing logic here
}
