import java.time.{ZoneId, ZonedDateTime}
import org.apache.spark.sql.functions._

val now = ZonedDateTime.now(ZoneId.of("Australia/Sydney"))
val currentHour = now.getHour

// Define expected cutoff times
val dailyCutoffHour = 13  // 1:00 PM AEST
val weeklyCutoffHour = 16 // 4:00 PM AEST

// Filter expected alerts with different cutoff times
val expectedAlerts = df2
  .filter(col("frequency") === "d" && currentHour >= dailyCutoffHour) // Daily alerts should arrive by 1 PM
  .select("alert_code")
  .distinct()
  .union(
    df2.filter(col("frequency") === "w" && col("run_days_dates") === todayNumber && currentHour >= weeklyCutoffHour) // Weekly alerts should arrive by 4 PM
      .select("alert_code")
      .distinct()
  )
  .union(
    df2.filter(col("frequency") === "m" && col("run_days_dates") === todaydayMonth) // Monthly alerts remain same
      .select("alert_code")
      .distinct()
  )
  .distinct()

val expectedAlertsDF = expectedAlerts.withColumn("alert_code", col("alert_code").cast(StringType))

expectedAlertsDF.show()






import java.util.{Calendar, TimeZone}

val aestZone = TimeZone.getTimeZone("Australia/Sydney")
val calNow = Calendar.getInstance(aestZone)
val currentHour = calNow.get(Calendar.HOUR_OF_DAY)
val currentMin = calNow.get(Calendar.MINUTE)

def sendMissedAlertsEmail(): Unit = {
    println("📩 Sending missed alerts email at 4:05 PM...")
    // Add logic to send missed alerts email
}

def sendConsolidatedEmail(): Unit = {
    println("📊 Sending consolidated email at 8:05 PM...")
    // Add logic to send consolidated email
}

def waitForTargetTime(targetHour: Int, targetMin: Int): Unit = {
    val targetCal = Calendar.getInstance(aestZone)
    targetCal.set(Calendar.HOUR_OF_DAY, targetHour)
    targetCal.set(Calendar.MINUTE, targetMin)
    targetCal.set(Calendar.SECOND, 0)
    targetCal.set(Calendar.MILLISECOND, 0)

    val nowMillis = System.currentTimeMillis()
    val targetMillis = targetCal.getTimeInMillis

    if (nowMillis < targetMillis) {
        val waitMillis = targetMillis - nowMillis
        println(s"⏳ Waiting for ${(waitMillis / 1000)} seconds until $targetHour:$targetMin AEST...")
        Thread.sleep(waitMillis)
    }
}

// **✅ Handle 4:05 PM missed alerts**
if (currentHour == 16 && currentMin >= 5 && currentMin < 10) {
    sendMissedAlertsEmail() // Process missed alerts immediately
} else if (currentHour == 16 && currentMin < 5) {
    waitForTargetTime(16, 5)
    sendMissedAlertsEmail()
}

// **✅ Handle 8:05 PM consolidated email**
else if (currentHour == 20 && currentMin >= 5 && currentMin < 10) {
    sendConsolidatedEmail() // Send consolidated email immediately
} else if (currentHour == 20 && currentMin < 5) {
    waitForTargetTime(20, 5)
    sendConsolidatedEmail()
}

// **✅ Run normal processing if not 4:05 PM or 8:05 PM**
else {
    println("⚡ Running other tasks as usual...")
    // Add normal data processing logic here
}
