// Step 1: Broadcast JDBC properties
val jdbcProps = Map(
  "url" -> props.getProperty("jdbc.url"),
  "user" -> props.getProperty("jdbc.user"),
  "password" -> props.getProperty("jdbc.password")
)

val broadcastJdbcProps = sc.broadcast(jdbcProps)

// Step 2: Use rdd.foreachPartition to create a connection and apply methods
rdd.foreachPartition(partition => {
  // Get JDBC properties from broadcast variable
  val jdbcUrl = broadcastJdbcProps.value("url")
  val jdbcUser = broadcastJdbcProps.value("user")
  val jdbcPassword = broadcastJdbcProps.value("password")

  // Create a JDBC connection for this partition
  val conn_rss = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)

  try {
    // Define methods locally
    def insertRecord(record: String): Unit = {
      val statement = conn_rss.prepareStatement("INSERT INTO some_table (column_name) VALUES (?)")
      statement.setString(1, record)
      statement.executeUpdate()
      statement.close()
    }

    def updateRecord(record: String): Unit = {
      val statement = conn_rss.prepareStatement("UPDATE some_table SET column_name = ? WHERE id = ?")
      statement.setString(1, record)
      statement.setInt(2, 1) // Example value for id
      statement.executeUpdate()
      statement.close()
    }

    def performOtherOperations(record: String): Unit = {
      // Add your custom logic here
      println(s"Processing record: $record")
    }

    // Step 3: Iterate through the partition and apply methods
    partition.foreach(record => {
      // Call the methods as needed
      insertRecord(record.toString)
      updateRecord(record.toString)
      performOtherOperations(record.toString)
    })

  } finally {
    // Step 4: Close the connection to release resources
    conn_rss.close()
  }
})
