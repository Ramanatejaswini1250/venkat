import java.nio.file.{Files, Paths, Path, StandardCopyOption}
import scala.util.{Try, Success, Failure}
import java.io.File

object RampAutomationExecution {
  def main(args: Array[String]): Unit = {
    val tempDir = "/path/to/tempDir" // Replace with the actual temp directory
    val finalPath = "/path/to/finalDir" // Replace with the actual target directory
    movePartFile(tempDir, finalPath)
  }

 import java.io.File
import java.nio.file.{Files, Path, Paths, StandardCopyOption}
import scala.util.{Failure, Success, Try}

import java.io.File
import java.nio.file.{Files, Path, Paths, StandardCopyOption}
import scala.util.{Failure, Success, Try}

// Create a temporary folder in the source directory if it does not exist
def createTempFolderIfNeeded(sourceDir: String): File = {
  val tempDir = new File(sourceDir, "tmp") // Define the tmp folder inside the source directory
  if (!tempDir.exists()) {
    if (tempDir.mkdirs()) {
      println(s"Temporary directory created: ${tempDir.getAbsolutePath}")
    } else {
      println(s"Failed to create temporary directory: ${tempDir.getAbsolutePath}")
    }
  }
  tempDir
}

// Move .csv files from the part file to the destination
def moveCsvFilesToDestination(partFile: File, destinationDir: String): Unit = {
  val sourcePath = partFile.toPath
  val destinationPath = Paths.get(destinationDir)

  // Ensure the destination directory exists
  if (!Files.exists(destinationPath)) {
    Files.createDirectories(destinationPath)
    println(s"Created destination directory: $destinationDir")
  }

  // Move .csv files from the part file to the destination
  partFile.listFiles().filter(_.getName.endsWith(".csv")).foreach { csvFile =>
    val csvDestination = Paths.get(destinationDir, csvFile.getName)
    Try {
      Files.move(csvFile.toPath, csvDestination, StandardCopyOption.REPLACE_EXISTING)
    } match {
      case Success(_) =>
        println(s"Moved file: ${csvFile.getName} to $destinationDir")
      case Failure(e) =>
        println(s"Error moving file: ${csvFile.getName}, ${e.getMessage}")
        e.printStackTrace()
    }
  }
}

// Main function to move the part file and clean up
def movePartFile(tempDir: String, finalPath: String): Unit = {
  val partFileOption: Option[File] = Option(new File(tempDir).listFiles())
    .flatMap(_.find(_.getName.startsWith("part")))

  partFileOption match {
    case Some(partFile) =>
      // Create a temporary folder inside the source directory if it doesn't exist
      val tempDirCreated = createTempFolderIfNeeded(tempDir)

      // Move the .csv files from the part file to the destination directory
      moveCsvFilesToDestination(partFile, finalPath)

      // Clean up the temporary folder (if needed)
      Try {
        partFile.listFiles().foreach(_.delete()) // Delete .csv files inside the part file folder
        partFile.delete() // Delete the part file folder itself
        println(s"Cleaned up the part file: ${partFile.getAbsolutePath}")
      } match {
        case Success(_) =>
          println(s"Temporary part file cleaned up successfully.")
        case Failure(e) =>
          println(s"Error during cleanup: ${e.getMessage}")
          e.printStackTrace()
      }

    case None =>
      println(s"Warning: No part file found in directory: $tempDir")
  }
}

}
