def runSqlScript(conn_rss: Connection, stmt_rss: Statement, scriptPath: String): Unit = {
  println(s"Running SQL script from: $scriptPath")

  var currentCommand: Option[String] = None // To track the currently executing command

  try {
    val logBuffer = new StringBuilder
    conn_rss.setAutoCommit(false)
    stmt_rss.setQueryTimeout(30) // Set a 30-second timeout for each query

    // Step 1: Read and process the script
    println("Reading SQL script...")
    val scriptContent = readFileAsString(scriptPath)
    val scriptWithoutComments = removeBlockComments(scriptContent)
    val lines = scriptWithoutComments.split("\n").toList

    // Step 2: Filter valid lines
    var validLines = lines
      .map(_.trim)
      .filter(_.nonEmpty)

    // Step 3: Identify master tables (e.g., _MASTER_TARGET1_TEST)
    val masterTables = validLines.flatMap(extractTableName).filter(_.toUpperCase.contains("_MASTER_TARGET1_TEST"))

    println(s"Extracted master tables: ${masterTables.mkString(", ")}")

    // Step 4: Execute DELETE statements for master tables
    val deleteStatements = masterTables.map(table => s"DELETE FROM $table;")
    deleteStatements.foreach { deleteStmt =>
      currentCommand = Some(deleteStmt) // Track the current command
      println(s"Executing DELETE statement: $deleteStmt")
      stmt_rss.execute(deleteStmt)
    }

    // Step 5: Process remaining commands that are not DELETE statements
    val remainingCommands = validLines.filterNot { line =>
      deleteStatements.exists(deleteStmt => line.toUpperCase.contains(deleteStmt.toUpperCase))
    }

    // Step 6: Execute remaining valid SQL commands
    remainingCommands.foreach { command =>
      currentCommand = Some(command) // Track the current command
      println(s"Executing command: $command")
      stmt_rss.execute(command)
      logBuffer.append(s"Executed: $command\n")
    }

    conn_rss.commit()
    println("SQL script executed successfully.")
  } catch {
    case e: Exception =>
      e.printStackTrace()
      val failedCommand = currentCommand.getOrElse("Unknown Command")
      val failedTableName = extractTableName(failedCommand)
      println(s"Rolled back due to an error while executing command: $failedCommand")
      println(s"Table involved: ${failedTableName.getOrElse("Unknown Table")}")
      conn_rss.rollback()
  }
}

// Function to extract table name from an SQL command
def extractTableName(command: String): Option[String] = {
  val tableRegex = "(?i)(?:from|join)\\s+([\\w_\\.]+)".r
  tableRegex.findFirstMatchIn(command).map(_.group(1)) // Return the first match if found
}
