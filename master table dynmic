def runSqlScript(conn_rss: Connection, stmt_rss: Statement, scriptPath: String): Unit = {
  println(s"Running SQL script from: $scriptPath")

  try {
    val logBuffer = new StringBuilder
    conn_rss.setAutoCommit(false)
    stmt_rss.setQueryTimeout(30) // Set a 30-second timeout for each query

    // Step 1: Read and process the script
    println("Reading SQL script...")
    val scriptContent = readFileAsString(scriptPath)
    val scriptWithoutComments = removeBlockComments(scriptContent)
    val lines = scriptWithoutComments.split("\n").toList

    // Step 2: Filter valid lines
    var validLines = lines
      .map(_.trim)
      .filter(_.nonEmpty)

    // Step 3: Identify master tables (e.g., _MASTER_TARGET1_TEST)
    val masterTables = validLines.flatMap(extractTableName).filter(_.toUpperCase.contains("_MASTER_TARGET1_TEST"))

    println(s"Extracted master tables: ${masterTables.mkString(", ")}")

    // Step 4: Execute DELETE statements for master tables
    val deleteStatements = masterTables.map(table => s"DELETE FROM $table;")
    deleteStatements.foreach { deleteStmt =>
      println(s"Executing DELETE statement: $deleteStmt")
      stmt_rss.execute(deleteStmt)
    }

    // Step 5: Process remaining commands that are not DELETE statements
    val remainingCommands = validLines.filterNot { line =>
      deleteStatements.exists(deleteStmt => line.toUpperCase.contains(deleteStmt.toUpperCase))
    }

    // Step 6: Execute remaining valid SQL commands
    remainingCommands.foreach { command =>
      println(s"Executing command: $command")
      stmt_rss.execute(command)
      logBuffer.append(s"Executed: $command\n")
    }

    conn_rss.commit()
    println("SQL script executed successfully.")
  } catch {
    case e: Exception =>
      e.printStackTrace()
      conn_rss.rollback()
      println("Rolled back due to an error.")
  }
}
