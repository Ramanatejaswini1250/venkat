import java.nio.file.{Files, Paths}
import java.nio.charset.StandardCharsets
import java.io.IOException

// Function to read file content as a String
def readFileAsString(path: String): String = {
  try {
    val bytes = Files.readAllBytes(Paths.get(path))
    new String(bytes, StandardCharsets.UTF_8)
  } catch {
    case e: IOException =>
      println(s"Error in reading file: ${e.getMessage}")
      throw e
  }
}

// Function to handle the SQL execution logic
def runSqlScript(scriptPath: String, jdbcUrl: String, jdbcUser: String, jdbcPassword: String, jdbcDriver: String): Unit = {
  println(s"Running SQL script from: $scriptPath")

  try {
    // Register JDBC driver
    println("Registering JDBC driver...")
    Class.forName(jdbcDriver)

    // Establish connection
    println(s"Connecting to database at: $jdbcUrl")
    val connection = java.sql.DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)
    val statement = connection.createStatement()

    // Read and clean SQL script content
    val scriptContent = readFileAsString(scriptPath)
    println(scriptContent) // Optionally log the content

    // Execute the cleaned SQL commands
    val commands = cleanAndSplitSqlContent(scriptContent)

    commands.foreach { command =>
      try {
        statement.execute(command) // Execute each SQL command
        println(s"Executed command: $command")
      } catch {
        case ex: Exception =>
          val tableName = extractTableName(command)
          val errorMsg = s"[ERROR] Failed to execute command on table: $tableName\nMessage: ${ex.getMessage}"
          println(errorMsg)
      }
    }
  } catch {
    case ex: Exception =>
      println(s"[ERROR] Execution failed: ${ex.getMessage}")
  }
}

// Function to clean and split SQL content
def cleanAndSplitSqlContent(scriptContent: String): Seq[String] = {
  val cleanedContent = scriptContent.replaceAll("[\\p{Cntrl}&&[^\r\n\t]]", "") // Remove control characters except for newlines and tabs
                                    .replaceAll("\r?\n", " ") // Replace newlines with a space
  cleanedContent.split(";").map(_.trim).filter(_.nonEmpty)
}

// Extract table name from SQL command (simple logic based on 'FROM' keyword)
def extractTableName(command: String): String = {
  val tableNamePattern = "(?i)from\\s+([\\w_]+)".r
  tableNamePattern.findFirstMatchIn(command) match {
    case Some(matched) => matched.group(1)
    case None => "Unknown"
  }
}

def mainProcess(sourceTableCount: Int, dtCount: Int, frequency: String, bteqLocation: String, alertCode: String, emailAddress: String, business: String): Unit = {
  if (sourceTableCount == dtCount) {
    val sqlFolderPath = getSqlFolderPath(frequency, bteqLocation)

    if (sqlFolderPath != null && sqlFolderPath.nonEmpty) {
      val cleanedSqlFolderPath = cleanFolderPath(sqlFolderPath)

      if (Files.exists(Paths.get(cleanedSqlFolderPath))) {
        val sqlFilePath = s"$cleanedSqlFolderPath/$alertCode.sql"
        val cleanSqlFilePath = cleanFolderPath(sqlFilePath)

        if (Files.exists(Paths.get(cleanSqlFilePath))) {
          // Now call the function to run the SQL script
          runSqlScript(cleanSqlFilePath, "jdbcUrl", "jdbcUser", "jdbcPassword", "jdbcDriver")

          // Send success email notification
          sendEmailNotification(alertCode, "SQL script executed successfully", emailAddress, business)
        } else {
          val message = s"SQL file not found for alertCode: $alertCode at path: $cleanSqlFilePath"
          sendEmailNotification(alertCode, message, emailAddress, business)
          println(message)
        }
      } else {
        val message = s"Folder not found for frequency: $frequency at path: $cleanedSqlFolderPath"
        sendEmailNotification(alertCode, message, emailAddress, business)
        println(message)
      }
    } else {
      val message = s"SQL folder path is empty or null for frequency: $frequency"
      sendEmailNotification(alertCode, message, emailAddress, business)
      println(message)
    }
  } else {
    val message = s"Source table count does not match DT_COUNT"
    sendEmailNotification(alertCode, message, emailAddress, business)
    println(message)
  }
}

// Function to clean folder paths
def cleanFolderPath(path: String): String = {
  path.replaceAll("[\\p{Cntrl}&&[^\r\n\t/\\:.-]]", "")  // Remove unwanted control characters
      .replaceAll("\\s+", "")                            // Remove unwanted spaces
      .replaceAll("\\$", "")                             // Remove dollar signs
      .replaceAll("\\.$", "")                            // Remove trailing dots
      .replaceAll("[^/a-zA-Z0-9._-]", "")                // Keep valid path characters
}

