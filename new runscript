import java.io.{BufferedReader, FileReader}
import java.sql.{Connection, DriverManager, Statement}
import java.text.SimpleDateFormat
import java.util.Calendar
import java.nio.file.{Files, Paths}
import java.nio.charset.StandardCharsets
import scala.collection.mutable.ArrayBuffer

// Function to generate a timestamped file name
def getCurrentTimestamp: String = {
  val format = new SimpleDateFormat("yyyyMMddHHmmss")
  format.format(Calendar.getInstance().getTime)
}

// Function to check if a line is a comment
def isCommentLine(line: String): Boolean = {
  line.trim.startsWith("--") || line.trim.isEmpty
}

def runSqlScript(scriptPath: String, jdbcUrl: String, jdbcUser: String, jdbcPassword: String, jdbcDriver: String): Unit = {
  println(s"Running SQL script from: $scriptPath")
  val logPath = s"sql_execution_log_${getCurrentTimestamp}.txt" // Log file to save execution details
  val logBuffer = new StringBuilder

  // Register the JDBC driver
  Class.forName(jdbcDriver)

  // Establish a connection
  val connection: Connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)
  val statement: Statement = connection.createStatement()

  // Read the SQL script line by line
  val reader = new BufferedReader(new FileReader(scriptPath))
  var line: String = reader.readLine()
  var lineNumber = 1

  // Initialize an ArrayBuffer to hold the lines
  val linesBuffer = ArrayBuffer[String]()

  // Read the entire file and store the lines
  while (line != null) {
    linesBuffer += line
    line = reader.readLine()
    lineNumber += 1
  }

  // Now process the lines, skipping the first 4 and the last 3, and ignoring comments
  val validLines = linesBuffer
    .drop(4) // Skip the first 4 lines
    .dropRight(3) // Skip the last 3 lines
    .filterNot(isCommentLine) // Ignore commented lines

  // Combine the valid lines into a single string
  val combinedScript = validLines.mkString("\n")

  // Split the script by semicolons to get individual SQL statements
  val sqlStatements = combinedScript.split(";").map(_.trim).filter(_.nonEmpty)

  // Execute the SQL commands
  sqlStatements.foreach { sql =>
    try {
      println(s"Executing: $sql")
      statement.execute(sql) // Execute the SQL command
      val successMsg = s"Executed successfully: $sql\n"
      println(successMsg)
      logBuffer.append(successMsg)
    } catch {
      case ex: Exception =>
        val errorMsg = s"Error executing SQL: $sql\nError Message: ${ex.getMessage}\n"
        println(errorMsg)
        logBuffer.append(errorMsg)
    }
  }

  // Save the execution log to a file
  Files.write(Paths.get(logPath), logBuffer.toString().getBytes(StandardCharsets.UTF_8))
  println(s"Execution log saved to: $logPath")

  // Close resources
  reader.close()
  statement.close()
  connection.close()
}

// Example usage
// Make sure to replace these values with actual parameters
val scriptPath = "path/to/your/sqlfile.sql"
val jdbcUrl = "jdbc:your_database_url"
val jdbcUser = "your_database_username"
val jdbcPassword = "your_database_password"
val jdbcDriver = "your.jdbc.Driver"

runSqlScript(scriptPath, jdbcUrl, jdbcUser, jdbcPassword, jdbcDriver)
