import java.nio.file.{Files, Paths}
import scala.io.Source
import java.sql.{Connection, Statement}

df.foreachPartition { partition =>
  partition.foreach { row =>
    val alertCode = row.getAs[String]("alert_code")
    val dtCount = row.getAs[Int]("dt_count")
    val dateToLoad = row.getAs[String]("date_to_load")
    val bteqLocation = row.getAs[String]("bteq_location")
    val emailAddress = row.getAs[String]("email_address")
    val business = row.getAs[String]("business")

    val sourceTableName = row.getAs[String]("source_table_name").getOrElse {
      sendEmailNotification(alertCode, "Missing source_table_name", emailAddress, business)
      throw new Exception("Missing source_table_name")
    }

    val frequency = row.getAs[String]("frequency").getOrElse {
      sendEmailNotification(alertCode, "Missing frequency", emailAddress, business)
      throw new Exception("Missing frequency")
    }

    val filterColumn = row.getAs[String]("filter_column").getOrElse {
      sendEmailNotification(alertCode, "Missing filter_column", emailAddress, business)
      throw new Exception("Missing filter_column")
    }

    try {
      if (dtCount > 0) {
        val folderPath = getSqlFolderPath(frequency, bteqLocation)

        if (frequency == "W") {
          val currentDay = currentDateTime.getDayOfWeek
          if (currentDateTime.isAfter(cutoffTime) || currentDateTime.toLocalTime.isEqual(cutoffTime)) {
            if (!Files.exists(Paths.get(folderPath))) {
              val message = s"AlertCode $alertCode with frequency 'W' was not processed by the cutoff time. Folder $folderPath is missing."
              sendEmailNotification(alertCode, message, emailAddress, business)
            }
          }
        }

        if (frequency == "M") {
          val currentDate = LocalDate.now()
          val cutoffDate = currentDate.withDayOfMonth(10)
          val currentTime = LocalTime.now()
          if ((currentDate.isAfter(cutoffDate) || (currentDate.isEqual(cutoffDate) && currentTime.isAfter(cutoffTime)))) {
            val message = s"AlertCode $alertCode with frequency 'M' was not processed by the cutoff time. No alerts received."
            sendEmailNotification(alertCode, message, emailAddress, business)
          }
        }

        if (frequency == "Q") {
          val currentDate = LocalDate.now()
          val isFirstDayOfQuarter = List(1, 4, 7, 10).contains(currentDate.getMonthValue) && currentDate.getDayOfMonth == 1
          val currentTime = LocalTime.now()
          if (isFirstDayOfQuarter && currentTime.isAfter(cutoffTime)) {
            val message = s"AlertCode $alertCode with frequency 'Q' was not processed by the cutoff time. No alerts received."
            sendEmailNotification(alertCode, message, emailAddress, business)
          }
        }

        val jdbcQuery = s"(SELECT COUNT(*) AS cnt FROM $sourceTableName WHERE $filterColumn = '$dateToLoad') AS subquery"
        val sourceTableCountDF = spark.read
          .format("jdbc")
          .option("url", jdbcUrl)
          .option("dbtable", jdbcQuery)
          .option("user", jdbcUser)
          .option("password", jdbcPassword)
          .option("driver", jdbcDriver)
          .load()

        val sourceTableCount = sourceTableCountDF.collect()(0).getAs[Long]("cnt")

        if (sourceTableCount == dtCount) {
          val sqlFolderPath = getSqlFolderPath(frequency, bteqLocation)

          if (Files.exists(Paths.get(sqlFolderPath))) {
            val sqlFilePath = s"$sqlFolderPath/${alertCode}.sql"

            if (Files.exists(Paths.get(sqlFilePath))) {
              // Read the SQL file and split by ';' to get individual statements
              val sqlContent = Source.fromFile(sqlFilePath).getLines().mkString(" ")
              val sqlStatements = sqlContent.split(";").map(_.trim).filter(_.nonEmpty)

              // Get the connection and statement objects (conn_rss and stmt_rss)
              val conn_rss = getConnection() // Replace with your actual connection method
              val stmt_rss = conn_rss.createStatement()

              // Execute each SQL statement
              try {
                sqlStatements.foreach { sql =>
                  if (sql.startsWith("INSERT INTO")) {
                    // Find corresponding SELECT statement to extract columns
                    val tableName = sql.split(" ")(2) // Extract the table name from INSERT INTO statement
                    val selectQuery = s"SELECT * FROM $tableName WHERE 1=0" // To fetch columns without any data

                    val selectResult = stmt_rss.executeQuery(selectQuery)
                    val columns = selectResult.getMetaData
                    val columnNames = (1 to columns.getColumnCount).map(columns.getColumnName).mkString(", ")

                    // Modify the INSERT statement to include column names if not present
                    val modifiedSql = if (!sql.contains("(")) {
                      s"$sql ($columnNames)"
                    } else {
                      sql
                    }

                    try {
                      stmt_rss.execute(modifiedSql)  // Execute the modified SQL statement
                      println(s"Executed SQL: $modifiedSql")
                    } catch {
                      case e: Exception =>
                        val message = s"Failed to execute SQL statement: $modifiedSql due to error: ${e.getMessage}"
                        sendEmailNotification(alertCode, message, emailAddress, business)
                    }
                  } else {
                    // Execute non-INSERT statements directly
                    try {
                      stmt_rss.execute(sql)
                      println(s"Executed SQL: $sql")
                    } catch {
                      case e: Exception =>
                        val message = s"Failed to execute SQL statement: $sql due to error: ${e.getMessage}"
                        sendEmailNotification(alertCode, message, emailAddress, business)
                    }
                  }
                }
                sendEmailNotification(alertCode, "SQL script executed successfully", emailAddress, business)
              } finally {
                stmt_rss.close()
                conn_rss.close()
              }
            } else {
              val message = s"SQL file not found for alertCode: $alertCode"
              sendEmailNotification(alertCode, message, emailAddress, business)
            }
          } else {
            val message = s"Folder not found for frequency: $frequency at path: $sqlFolderPath"
            sendEmailNotification(alertCode, message, emailAddress, business)
          }
        } else {
          val message = s"Source table count does not match DT_COUNT"
          sendEmailNotification(alertCode, message, emailAddress, business)
        }
      }
    } catch {
      case e: Exception =>
        sendEmailNotification(alertCode, s"An error occurred: ${e.getMessage}", emailAddress, business)
    }
  }
}
