import java.io.{BufferedReader, FileReader}
import java.sql.{Connection, DriverManager, Statement}
import java.text.SimpleDateFormat
import java.util.Calendar
import java.nio.file.{Files, Paths}
import java.nio.charset.StandardCharsets

// Function to generate a timestamped log file name
def getCurrentTimestamp: String = {
  val format = new SimpleDateFormat("yyyyMMddHHmmss")
  format.format(Calendar.getInstance().getTime)
}

def runSqlScript(scriptPath: String, jdbcUrl: String, jdbcUser: String, jdbcPassword: String, jdbcDriver: String): Unit = {
  println(s"Running SQL script from: $scriptPath")
  val logPath = s"sql_execution_log_${getCurrentTimestamp}.txt" // Log file to save execution details
  val logBuffer = new StringBuilder

  // Register the JDBC driver
  Class.forName(jdbcDriver)

  // Establish a connection
  val connection: Connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)
  val statement: Statement = connection.createStatement()

  // Read the SQL script line by line
  val reader = new BufferedReader(new FileReader(scriptPath))
  val lines = Iterator.continually(reader.readLine()).takeWhile(_ != null).toList
  reader.close()

  // Filter the SQL script lines
  val validLines = lines
    .drop(4) // Skip the first 4 lines
    .dropRight(3) // Skip the last 3 lines
    .filterNot(_.contains(".IF ERRORCODE <> 0 THEN .GOTO ERROR;")) // Skip specific lines
    .map(_.trim) // Trim each line

  val commandBuffer = new StringBuilder

  try {
    for (line <- validLines) {
      if (line.nonEmpty && !line.startsWith("--")) { // Skip empty lines and comments
        commandBuffer.append(line).append(" ")

        // Check if the command ends with `;`, indicating it's complete
        if (line.endsWith(";")) {
          val command = commandBuffer.toString().trim
          try {
            println(s"Executing command: $command")
            statement.execute(command) // Execute the complete SQL command
            val successMsg = s"Command executed successfully: $command\n"
            println(successMsg)
            logBuffer.append(successMsg)
          } catch {
            case ex: Exception =>
              val errorMsg = s"Error executing command: $command\nError Message: ${ex.getMessage}\n"
              println(errorMsg)
              logBuffer.append(errorMsg)
          }
          commandBuffer.clear() // Clear the buffer for the next command
        }
      }
    }
  } catch {
    case ex: Exception =>
      val fatalErrorMsg = s"Fatal error occurred: ${ex.getMessage}\n"
      println(fatalErrorMsg)
      logBuffer.append(fatalErrorMsg)
  } finally {
    // Save the execution log to a file
    Files.write(Paths.get(logPath), logBuffer.toString().getBytes(StandardCharsets.UTF_8))
    println(s"Execution log saved to: $logPath")

    // Close resources
    statement.close()
    connection.close()
  }
}

// Example usage (replace with your actual values)
val scriptPath = "path/to/your/sql_script.sql"
val jdbcUrl = "jdbc:mysql://localhost:3306/your_database"
val jdbcUser = "your_username"
val jdbcPassword = "your_password"
val jdbcDriver = "com.mysql.cj.jdbc.Driver"

runSqlScript(scriptPath, jdbcUrl, jdbcUser, jdbcPassword, jdbcDriver)
