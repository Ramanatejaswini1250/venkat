import java.sql.{Connection, Statement}
import java.util.Properties
import javax.mail._
import javax.mail.internet._

def runSqlScript(conn_rss: Connection, stmt_rss: Statement, scriptPath: String): Unit = {
  println(s"Running SQL script from: $scriptPath")

  var currentCommand: Option[String] = None // Track the current command
  val logBuffer = new StringBuilder
  conn_rss.setAutoCommit(false)

  try {
    println("Reading SQL script...")
    val scriptContent = readFileAsString(scriptPath)

    // Remove block comments (/* ... */)
    val scriptWithoutComments = removeBlockComments(scriptContent)

    // Split the script into lines
    val lines = scriptWithoutComments.split("\n").map(_.trim).filter(_.nonEmpty).toList

    // Extract master tables dynamically
    val masterTables = extractMasterTables(lines)

    // Log extracted master tables
    println(s"Extracted master tables: ${masterTables.mkString(", ")}")

    // Execute DELETE statements for master tables first
    masterTables.foreach { table =>
      val deleteStmt = s"DELETE FROM $table;"
      println(s"Executing: $deleteStmt")
      stmt_rss.execute(deleteStmt)
    }

    // Process remaining SQL queries
    val queries = lines.mkString("\n").split(";").map(_.trim).filter(_.nonEmpty)

    queries.foreach { query =>
      currentCommand = Some(query) // Track the current command

      val transformedQuery = transformInsertToIncludeColumns(query)

      println(s"Executing: $transformedQuery")
      stmt_rss.execute(transformedQuery)
      logBuffer.append(s"Executed: $transformedQuery\n")
    }

    // Commit transaction if all commands succeed
    conn_rss.commit()
    println("SQL script executed successfully.")

  } catch {
    case e: Exception =>
      e.printStackTrace()
      conn_rss.rollback()
      val failedQuery = currentCommand.getOrElse("Unknown Query")
      println(s"Rolled back due to error in query: $failedQuery")
      sendFailureEmail(failedQuery, e.getMessage)
  } finally {
    println("runSqlScript function completed.")
  }
}

// Extract table names after FROM, JOIN, or INSERT INTO
def extractTableName(command: String): String = {
  val tableRegex = """(?i)(?:INSERT INTO|FROM|JOIN)\s+([\w.]+)""".r
  tableRegex.findFirstMatchIn(command).map(_.group(1)).getOrElse("Unknown Table")
}

// Extract master tables dynamically
def extractMasterTables(commands: Seq[String]): Seq[String] = {
  val masterTablePattern = "(?i).*MASTER_TARGET[0-9]+.*".r
  commands.flatMap { command =>
    val tableName = extractTableName(command)
    if (masterTablePattern.findFirstIn(tableName).isDefined) Some(tableName) else None
  }.distinct
}

// Remove block comments (/* ... */)
def removeBlockComments(script: String): String = {
  val blockCommentRegex = "/\\*.*?\\*/".r
  blockCommentRegex.replaceAllIn(script, "")
}

// Transform INSERT INTO ... SELECT to include column names
def transformInsertToIncludeColumns(query: String): String = {
  val insertSelectPattern = """(?i)INSERT INTO\s+(\w+)\s+SELECT\s+(.+?)\s+FROM\s+(\w+)""".r
  query match {
    case insertSelectPattern(tableName, columns, selectTable) =>
      s"INSERT INTO $tableName ($columns) SELECT $columns FROM $selectTable"
    case _ => query // Return original if no transformation needed
  }
}

}
