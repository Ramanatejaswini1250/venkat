import org.apache.spark.util.CollectionAccumulator
import java.sql.{Connection, Statement}
import scala.collection.mutable.ListBuffer

object RampAutomationExecution {
    def main(args: Array[String]): Unit = {
        val spark = org.apache.spark.sql.SparkSession.builder().appName("RampAutomationExecution").getOrCreate()

        // Accumulator to collect failed SQL queries
        val failedSqlAccumulator = spark.sparkContext.collectionAccumulator[String]("Failed SQL Queries")

        // Load DataFrame (assuming df is already created)
        val df = spark.read.format("your_format").load("your_data_source")

        // Execute SQL for each partition
        df.foreachPartition { partition =>
            val conn_rss = getConnection() // Get DB connection
            val stmt_rss = conn_rss.createStatement()
            try {
                runSqlScript(conn_rss, stmt_rss, "your_script_path", failedSqlAccumulator) // Run SQL
            } finally {
                stmt_rss.close()
                conn_rss.close() // Close connection
            }
        }

        // Send failure email from driver after all partitions complete
        if (!failedSqlAccumulator.value.isEmpty) {
            val errorReport = failedSqlAccumulator.value.mkString("\n")
            println(s"Sending failure email: \n$errorReport")

            sendEmailNotification(
                "SQL Execution Failed",
                s"Errors encountered during SQL execution:\n\n$errorReport",
                "CDAORiskAlertDeliveryTeam@cba.com.au"
            )
        }

        spark.stop()
    }

    def runSqlScript(
        conn_rss: Connection,
        stmt_rss: Statement,
        scriptPath: String,
        failedSqlAccumulator: CollectionAccumulator[String]
    ): (String, String) = {
        var currentCommand: Option[String] = None
        val executedQueries = ListBuffer[String]() // Track executed queries

        try {
            conn_rss.setAutoCommit(false)
            stmt_rss.setQueryTimeout(30) // Set query timeout

            println("Reading SQL script...")
            val scriptContent = readFileAsString(scriptPath)
            val scriptWithoutComments = removeBlockComments(scriptContent)

            val lines = scriptWithoutComments.split("\n").toList

            // Filter the lines
            val validLines = lines
                .drop(4) // Skip first 4 lines
                .dropRight(4) // Skip last 4 lines
                .map(removeInlineComments) // Remove inline comments
                .filterNot(_.trim.toUpperCase.contains("IF ERRORCODE <> 0 THEN .GOTO ERROR;"))
                .filter(_.nonEmpty) // Remove empty lines

            // Extract master tables dynamically
            val masterTables = extractMasterTables(validLines)
            println(s"Extracted master tables: ${masterTables.mkString(", ")}")

            val masterTable1 = if (masterTables.nonEmpty) masterTables.head else "default_mastertable1"
            val masterTable2 = if (masterTables.length > 1) masterTables(1) else "default_mastertable2"

            var hasFailures = false

            // Process SQL queries
            val commands = validLines.mkString("\n").split(";").map(_.trim).filter(_.nonEmpty)
            for (query <- commands) {
                currentCommand = Some(query) // Track current command

                val transformedQuery = if (query.toUpperCase.startsWith("INSERT INTO")) {
                    transformInsertToIncludeColumns(query, stmt_rss)
                } else {
                    query
                }

                println(s"Executing transformed query: $transformedQuery")
                try {
                    stmt_rss.execute(transformedQuery)
                    executedQueries += transformedQuery // Log executed query
                } catch {
                    case e: Exception =>
                        val failedCommand = currentCommand.getOrElse("Unknown Command")
                        val failedTableName = extractTableName(failedCommand)
                        val errorMsg = s"Table Execution Failed: $failedTableName. ${e.getMessage}"

                        println(errorMsg)
                        failedSqlAccumulator.add(errorMsg) // Capture failure in accumulator
                        hasFailures = true // Mark failure
                }
            }

            if (hasFailures) {
                conn_rss.rollbac
