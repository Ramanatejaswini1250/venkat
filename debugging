import org.apache.spark.util.CollectionAccumulator
import java.sql.Connection
import scala.collection.mutable.ListBuffer

object RampAutomationExecution {
    def main(args: Array[String]): Unit = {
        val spark = org.apache.spark.sql.SparkSession.builder().appName("RampAutomationExecution").getOrCreate()

        // Accumulator to collect failed SQL queries
        val failedSqlAccumulator = spark.sparkContext.collectionAccumulator[String]("Failed SQL Queries")

        // Load DataFrame (assuming df is already created)
        val df = spark.read.format("your_format").load("your_data_source")

        // Execute SQL for each partition
        df.foreachPartition { partition =>
            val conn_rss = getConnection() // Get DB connection
            try {
                runSqlScript(conn_rss, failedSqlAccumulator) // Run SQL and collect failures
            } finally {
                conn_rss.close() // Close connection
            }
        }

        // Send failure email from driver after all partitions complete
        if (!failedSqlAccumulator.value.isEmpty) {
            val errorReport = failedSqlAccumulator.value.mkString("\n")
            println(s"Sending failure email: \n$errorReport")

            sendEmailNotification(
                "SQL Execution Failed",
                s"Errors encountered during SQL execution:\n\n$errorReport",
                "CDAORiskAlertDeliveryTeam@cba.com.au"
            )
        }

        spark.stop()
    }

    def runSqlScript(conn_rss: Connection, failedSqlAccumulator: CollectionAccumulator[String]): Unit = {
        var currentCommand: Option[String] = None
        val executedQueries = ListBuffer[String]() // Track executed queries

        try {
            conn_rss.setAutoCommit(false)
            val stmt_rss = conn_rss.createStatement()
            stmt_rss.setQueryTimeout(30) // Set query timeout

            println("Reading SQL script...")
            val scriptContent = readFileAsString(scriptPath)
            val scriptWithoutComments = removeBlockComments(scriptContent)

            val lines = scriptWithoutComments.split("\n").toList

            // Filter the lines
            val validLines = lines
                .drop(4) // Skip first 4 lines
                .dropRight(4) // Skip last 4 lines
                .map(removeInlineComments) // Remove inline comments
                .filterNot(_.trim.toUpperCase.contains("IF ERRORCODE <> 0 THEN .GOTO ERROR;"))
                .filter(_.nonEmpty) // Remove empty lines

            val commands = validLines.mkString("\n").split(";").map(_.trim).filter(_.nonEmpty)

            var hasFailures = false

            commands.foreach { query =>
                currentCommand = Some(query) // Track current command

                val transformedQuery = if (query.toUpperCase.startsWith("INSERT INTO")) {
                    transformInsertToIncludeColumns(query, stmt_rss)
                } else {
                    query
                }

                println(s"Executing transformed query: $transformedQuery")
                try {
                    stmt_rss.execute(transformedQuery)
                    executedQueries += transformedQuery // Log executed query
                } catch {
                    case e: Exception =>
                        val failedCommand = currentCommand.getOrElse("Unknown Command")
                        val failedTableName = extractTableName(failedCommand)
                        val errorMsg = s"Table Execution Failed: $failedTableName. ${e.getMessage}"

                        println(errorMsg)
                        failedSqlAccumulator.add(errorMsg) // Capture failure in accumulator

                        hasFailures = true // Mark that a failure occurred
                }
            }

            if (hasFailures) {
                conn_rss.rollback() // Rollback if any SQL query fails
            } else {
                conn_rss.commit() // Commit only if all queries succeed
            }

        } catch {
            case ex: Exception =>
                ex.printStackTrace()
                val failedCommand = currentCommand.getOrElse("Unknown Command")
                val failedTableName = extractTableName(failedCommand)
                val errorMsg = s"Critical SQL Failure: $failedTableName. ${ex.getMessage}"

                println(errorMsg)
                failedSqlAccumulator.add(errorMsg) // Capture failure in accumulator
                conn_rss.rollback()
        } finally {
            conn_rss.setAutoCommit(true) // Reset auto-commit mode
        }
    }

    def sendEmailNotification(subject: String, body: String, recipient: String): Unit = {
        // Implement your email sending logic here
        println(s"Email sent to $recipient with subject: $subject\nBody:\n$body")
    }

    def getConnection(): Connection = {
        // Implement your DB connection logic here
        ???
    }

    def readFileAsString(path: String): String = {
        // Implement file reading logic
        ???
    }

    def removeBlockComments(script: String): String = {
        // Implement block comment removal logic
        ???
    }

    def removeInlineComments(line: String): String = {
        // Implement inline comment removal logic
        ???
    }
}
