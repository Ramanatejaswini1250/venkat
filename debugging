import java.sql.{Connection, Statement}
import java.util.concurrent.ConcurrentLinkedQueue
import org.apache.spark.sql.{DataFrame, SparkSession}
import scala.collection.mutable.ListBuffer

object RampAutomationExecution {

  def runSqlScript(
      conn_rss: Connection,
      stmt_rss: Statement,
      scriptPath: String,
      failedSqlQueue: ConcurrentLinkedQueue[String]
  ): (String, String) = {

    println(s"Running SQL script from: $scriptPath")

    var currentCommand: Option[String] = None
    val executedQueries = ListBuffer[String]() // Track executed queries
    val failedQueries = ListBuffer[String]()   // Track failed queries

    try {
      conn_rss.setAutoCommit(false)
      stmt_rss.setQueryTimeout(30) // Set query timeout to 30 seconds

      println("Reading SQL script...")
      val scriptContent = readFileAsString(scriptPath)
      val scriptWithoutComments = removeBlockComments(scriptContent)

      val lines = scriptWithoutComments.split("\n").toList

      // Process SQL script: remove first & last 4 lines, inline comments, and unnecessary lines
      val validLines = lines
        .drop(4)
        .dropRight(4)
        .map(removeInlineComments)
        .filterNot(line =>
          line.trim.toUpperCase.contains("IF ERRORCODE <> 0 THEN .GOTO ERROR;".toUpperCase)
        )
        .filter(_.nonEmpty)

      // Extract master tables dynamically
      val masterTables = extractMasterTables(validLines)
      println(s"Extracted master tables: ${masterTables.mkString(", ")}")

      val masterTable1 = if (masterTables.nonEmpty) masterTables.head else "default_mastertable1"
      val masterTable2 = if (masterTables.length > 1) masterTables(1) else "default_mastertable2"

      // DELETE existing data from master tables before loading new data
      masterTables.foreach { table =>
        val deleteStmt = s"DELETE FROM $table;"
        println(s"Executing: $deleteStmt")
        stmt_rss.execute(deleteStmt)
        executedQueries += deleteStmt
      }

      // Execute remaining SQL queries
      val remainingCommands = validLines.mkString("\n").split(";").map(_.trim).filter(_.nonEmpty)
      for (query <- remainingCommands) {
        currentCommand = Some(query) // Track the current command

        // Transform INSERT INTO queries to include column names if needed
        val transformedQuery = if (query.toUpperCase.startsWith("INSERT INTO")) {
          transformInsertToIncludeColumns(query, stmt_rss)
        } else {
          query
        }

        println(s"Executing: $transformedQuery")
        try {
          stmt_rss.execute(transformedQuery)
          executedQueries += transformedQuery
        } catch {
          case e: Exception =>
            val failedCommand = currentCommand.getOrElse("Unknown Command")
            failedQueries += failedCommand
            failedSqlQueue.add(failedCommand) // Add failed query to queue

            println(s"Failed to execute query: $failedCommand. Error: ${e.getMessage}")

            conn_rss.rollback() // Rollback on failure
            throw new RuntimeException(s"SQL Execution Failed: $failedCommand. ${e.getMessage}")
        }
      }

      conn_rss.commit() // Commit only if all queries run successfully
      println("SQL script executed successfully.")

      (masterTable1, masterTable2) // Return master tables
    } catch {
      case ex: Exception =>
        ex.printStackTrace()
        val failedCommand = currentCommand.getOrElse("Unknown Command")
        failedQueries += failedCommand
        failedSqlQueue.add(failedCommand) // Add failed query to queue

        println(s"Critical Error: $failedCommand. ${ex.getMessage}")

        conn_rss.rollback() // Rollback on failure
        throw new RuntimeException(s"SQL Execution Failed: $failedCommand. ${ex.getMessage}")
    } finally {
      conn_rss.setAutoCommit(true) // Reset auto-commit mode
    }
  }

  def executeWithSpark(df: DataFrame, spark: SparkSession): Unit = {
    // **Broadcast a thread-safe queue for failed SQL queries**
    val failedSqlBroadcast = spark.sparkContext.broadcast(new ConcurrentLinkedQueue[String]())

    df.foreachPartition { partition =>
      val conn_rss = getConnection() // Get DB connection
      val stmt_rss = conn_rss.createStatement()
      try {
        runSqlScript(conn_rss, stmt_rss, "your_script_path", failedSqlBroadcast.value) // Run SQL
      } finally {
        stmt_rss.close()
        conn_rss.close() // Close connection
      }
    }

    // **After foreachPartition completes, check failed SQL queries and send email if needed**
    val failedSqlList = failedSqlBroadcast.value.toArray.mkString("\n")

    if (failedSqlList.nonEmpty) {
      println(s"ðŸš¨ SQL Failures Detected. Sending Email...\n$failedSqlList")
      sendEmailNotification(
        "SQL Execution Failed",
        s"Failed Queries:\n$failedSqlList",
        "CDAORiskAlertDeliveryTeam@cba.com.au"
      )
    } else {
      println("âœ… All SQL queries executed successfully.")
    }
  }
}
