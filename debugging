// Store failed queries in a shared list
val failedQueriesList = new java.util.concurrent.ConcurrentLinkedQueue[String]()

def runSqlScript(conn_rss: Connection): Unit = {
    println(s"Running SQL script...")

    var currentCommand: Option[String] = None
    val executedQueries = ListBuffer[String]()
    
    try {
        conn_rss.setAutoCommit(false)
        stmt_rss.setQueryTimeout(30) // 30 seconds timeout for each query

        val scriptContent = readFileAsString(scriptPath)
        val scriptWithoutComments = removeBlockComments(scriptContent)

        val lines = scriptWithoutComments.split("\n").toList

        val validLines = lines
            .drop(4)
            .dropRight(4)
            .map(removeInlineComments)
            .filterNot(line => line.trim.toUpperCase.contains("IF ERRORCODE <> 0 THEN .GOTO ERROR;".toUpperCase))
            .filter(_.nonEmpty)

        val masterTables = extractMasterTables(validLines)

        masterTables.foreach { table =>
            val deleteStmt = s"DELETE FROM $table;"
            println(s"Executing: $deleteStmt")
            stmt_rss.execute(deleteStmt)
            executedQueries += deleteStmt
        }

        val remainingCommands = validLines.mkString("\n").split(";").map(_.trim).filter(_.nonEmpty)
        remainingCommands.foreach { query =>
            currentCommand = Some(query)

            val transformedQuery = if (query.toUpperCase.startsWith("INSERT INTO")) {
                transformInsertToIncludeColumns(query, stmt_rss)
            } else {
                query
            }

            println(s"Executing transformed query: $transformedQuery")
            try {
                stmt_rss.execute(transformedQuery)
                executedQueries += transformedQuery
            } catch {
                case e: Exception =>
                    val errorMsg = s"❌ SQL Execution Failed: $transformedQuery. Error: ${e.getMessage}"
                    println(errorMsg)

                    // Collect failed queries in a shared list
                    failedQueriesList.add(errorMsg)

                    throw new RuntimeException(errorMsg) // Stop execution after failure
            }
        }

        conn_rss.commit()
        println("✅ SQL script executed successfully.")
    } catch {
        case ex: Exception =>
            ex.printStackTrace()
            conn_rss.rollback() // Rollback on failure
            val fatalErrorMsg = s"🚨 Critical SQL Execution Failure: ${ex.getMessage}"
            failedQueriesList.add(fatalErrorMsg)
    } finally {
        conn_rss.setAutoCommit(true)
    }
}






df.foreachPartition { partition =>
    val conn_rss = getConnection() // Get database connection
    val stmt_rss = conn_rss.createStatement()

    partition.foreach { row =>
        try {
            runSqlScript(conn_rss)
        } catch {
            case e: Exception =>
                println(s"❌ Error processing partition: ${e.getMessage}")
        }
    }

    stmt_rss.close()
    conn_rss.close()
}

df.foreachPartition { partition =>
    val conn = getDatabaseConnection()
    val failedQueriesList = new java.util.concurrent.ConcurrentLinkedQueue[(String, String)]() // Store (alertCode, errorMessage)

    try {
        partition.foreach { row =>
            val alertCode = row.getAs[String]("alert_code")  // Extract alertCode from DataFrame
            try {
                runSqlScript(conn, failedQueriesList, alertCode)
            } catch {
                case e: Exception =>
                    val errorMsg = s"❌ SQL Execution Failed for AlertCode: $alertCode. Error: ${e.getMessage}"
                    println(errorMsg)
                    failedQueriesList.add((alertCode, errorMsg))
            }
        }
    } finally {
        conn.close()
    }

if (!failedQueriesList.isEmpty) {
    val failedAlertsArray = failedQueriesList.toArray().map(_.asInstanceOf[(String, String)])

    val groupedAlerts = failedAlertsArray
        .groupBy(_._1) // Group by alertCode
        .map { case (alertCode, alerts) =>
            val messages = alerts.map(_._2).distinct.mkString("\n") // Unique messages for each alert
            s"🔹 AlertCode: $alertCode\n$messages"
        }
        .mkString("\n\n")

    val uniqueAlertCodes = failedAlertsArray.map(_._1).distinct.mkString(", ")

    sendEmailNotification(
        uniqueAlertCodes,  
        s"🚨 SQL Execution Failed for Queries: \n$groupedAlerts",
        "CDAORiskAlertDeliveryTeam@cba.com.au",
        "Risk Alerts",
        ""
    )
}

