import java.nio.file.{Files, Paths}
import java.nio.charset.StandardCharsets
import java.sql.{Connection, DriverManager, ResultSet}
import scala.util.Try

object SqlScriptExecutor {

  // Fetch column names using "SHOW COLUMNS"
  def getTableColumns(
      jdbcUrl: String,
      jdbcUser: String,
      jdbcPassword: String,
      jdbcDriver: String,
      tableName: String
  ): Seq[String] = {
    Class.forName(jdbcDriver)
    var connection: Connection = null

    try {
      connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)
      val statement = connection.createStatement()

      // Use "SHOW COLUMNS FROM <tableName>"
      val query = s"SHOW COLUMNS FROM $tableName"
      val resultSet = statement.executeQuery(query)

      // Extract column names from the result
      val columns = Iterator
        .continually(resultSet)
        .takeWhile(_.next())
        .map(_.getString(1)) // Column names are typically in the first column
        .toSeq

      if (columns.isEmpty) throw new Exception(s"No columns found for table: $tableName")
      columns
    } catch {
      case ex: Exception =>
        throw new Exception(s"Error fetching columns for table $tableName: ${ex.getMessage}", ex)
    } finally {
      if (connection != null) connection.close()
    }
  }

  // Handle INSERT statements without column names
  def handleInsertWithoutColumns(
      jdbcUrl: String,
      jdbcUser: String,
      jdbcPassword: String,
      jdbcDriver: String,
      tableName: String,
      query: String
  ): String = {
    val columns = getTableColumns(jdbcUrl, jdbcUser, jdbcPassword, jdbcDriver, tableName)
    val columnsString = columns.map(col => s"`$col`").mkString(", ")

    if (columns.isEmpty) throw new Exception(s"No columns found for table: $tableName")

    // Replace the INSERT INTO statement
    query.replaceFirst("(?i)insert into\\s+\\w+", s"INSERT INTO $tableName ($columnsString)")
  }

  // Execute a SQL script using JDBC
  def runSqlScript(
      scriptPath: String,
      jdbcUrl: String,
      jdbcUser: String,
      jdbcPassword: String,
      jdbcDriver: String
  ): Unit = {
    println(s"Running SQL script from: $scriptPath")
    val logPath = s"sql_execution_log_${System.currentTimeMillis}.txt"
    val logBuffer = new StringBuilder

    Class.forName(jdbcDriver)

    try {
      val connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)
      val statement = connection.createStatement()

      // Read the SQL script
      val script = Files.readString(Paths.get(scriptPath), StandardCharsets.UTF_8)

      // Split the script into commands
      val commands = script.split(";").map(_.trim).filter(_.nonEmpty)

      commands.foreach { command =>
        try {
          if (command.toLowerCase.startsWith("insert into")) {
            val tableName = command.split(" ")(2) // Extract table name
            val processedCommand = handleInsertWithoutColumns(jdbcUrl, jdbcUser, jdbcPassword, jdbcDriver, tableName, command)
            println(s"Executing: $processedCommand")
            statement.execute(processedCommand)
          } else {
            println(s"Executing: $command")
            statement.execute(command)
          }
          val successMsg = s"[SUCCESS] Executed: $command"
          println(successMsg)
          logBuffer.append(successMsg + "\n")
        } catch {
          case ex: Exception =>
            val errorMsg = s"[ERROR] Failed to execute command: $command\nReason: ${ex.getMessage}"
            println(errorMsg)
            logBuffer.append(errorMsg + "\n")
        }
      }

      // Save execution log to a file
      Files.write(Paths.get(logPath), logBuffer.toString().getBytes(StandardCharsets.UTF_8))
      println(s"Execution log saved to: $logPath")

      // Close connection
      connection.close()
    } catch {
      case ex: Exception =>
        val fatalErrorMsg = s"[FATAL] Error: ${ex.getMessage}"
        println(fatalErrorMsg)
        logBuffer.append(fatalErrorMsg + "\n")
    }
  }

  // Main entry point
  def main(args: Array[String]): Unit = {
    val scriptPath = "path/to/your/sqlfile.sql"
    val jdbcUrl = "jdbc:your_database_url"
    val jdbcUser = "your_database_username"
    val jdbcPassword = "your_database_password"
    val jdbcDriver = "your.jdbc.Driver"

    runSqlScript(scriptPath, jdbcUrl, jdbcUser, jdbcPassword, jdbcDriver)
  }
}
