import java.nio.file.{Files, Paths}
import java.nio.file.attribute.FileTime
import java.util.concurrent.TimeUnit
import java.io.IOException
import java.sql.{Connection, DriverManager, Statement}
import scala.collection.JavaConverters._

object SqlUtils {

  // Method to get the column names of a table
  def getTableColumns(jdbcUrl: String, jdbcUser: String, jdbcPassword: String, jdbcDriver: String, tableName: String): Seq[String] = {
    var connection: Connection = null
    var statement: Statement = null

    try {
      // Register JDBC driver
      Class.forName(jdbcDriver)
      connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)
      statement = connection.createStatement()

      // Get the column names using JDBC metadata
      val resultSet = statement.executeQuery(s"SELECT * FROM $tableName LIMIT 1")
      val metadata = resultSet.getMetaData
      (1 to metadata.getColumnCount).map(metadata.getColumnName)
    } catch {
      case ex: Exception =>
        println(s"[ERROR] Failed to fetch columns for table $tableName: ${ex.getMessage}")
        Seq.empty
    } finally {
      if (statement != null) statement.close()
      if (connection != null) connection.close()
    }
  }

  // Method to handle insert statements without column names
  def processInsertQueries(query: String, tableName: String, columns: Seq[String]): String = {
    if (columns.isEmpty) {
      println(s"[WARNING] No columns fetched for table $tableName. Query may fail.")
      query
    } else {
      val columnsString = columns.mkString(", ")
      query.replaceFirst("(?i)insert into " + tableName, s"INSERT INTO $tableName ($columnsString)")
    }
  }
}

object SqlScriptExecutor {

  // Generate a timestamped log file name
  def getCurrentTimestamp: String = {
    val format = new java.text.SimpleDateFormat("yyyyMMddHHmmss")
    format.format(java.util.Calendar.getInstance().getTime)
  }

  // Function to remove block comments (/* ... */)
  def removeBlockComments(script: String): String = {
    val blockCommentPattern = "(?s)/\\*.*?\\*/".r
    blockCommentPattern.replaceAllIn(script, "") // Remove block comments
  }

  // Function to handle inline comments (--) while preserving SQL before them
  def removeInlineComments(line: String): String = {
    val singleLineCommentPattern = "--.*".r
    singleLineCommentPattern.replaceFirstIn(line, "").trim // Remove only the comment part
  }

  // Function to delete log files older than 24 hours
  def cleanOldLogFiles(logDirectory: String): Unit = {
    println(s"Cleaning up old log files from: $logDirectory")

    val logFiles = Files.list(Paths.get(logDirectory)).iterator().asScala
    val currentTime = System.currentTimeMillis()

    logFiles.foreach { logFile =>
      try {
        val fileTime: FileTime = Files.getLastModifiedTime(logFile)
        val fileAge = currentTime - fileTime.toMillis

        // Check if file is older than 24 hours
        if (fileAge > TimeUnit.HOURS.toMillis(24)) {
          println(s"Deleting old log file: ${logFile.getFileName}")
          Files.delete(logFile)
        }
      } catch {
        case e: IOException => println(s"Error checking file $logFile: ${e.getMessage}")
      }
    }
  }

  // Execute the SQL script
  def runSqlScript(scriptPath: String, jdbcUrl: String, jdbcUser: String, jdbcPassword: String, jdbcDriver: String): Unit = {
    println(s"Running SQL script from: $scriptPath")
    val logPath = s"sql_execution_log_${getCurrentTimestamp}.txt"
    val logBuffer = new StringBuilder

    var connection: Connection = null
    var statement: Statement = null

    try {
      // Register JDBC driver
      println("Registering JDBC driver...")
      Class.forName(jdbcDriver)

      // Establish connection
      println(s"Connecting to database at: $jdbcUrl")
      connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)
      statement = connection.createStatement()

      // Read the SQL script
      println("Reading SQL script...")
      val script = Files.readString(Paths.get(scriptPath), java.nio.charset.StandardCharsets.UTF_8)

      // Process the script: remove block comments and split into lines
      val scriptWithoutComments = removeBlockComments(script)
      val lines = scriptWithoutComments.split("\n").toSeq

      // Prepare and filter valid lines
      val validLines = lines
        .map(removeInlineComments) // Remove inline comments (-- ...)
        .filter(_.nonEmpty) // Remove empty or whitespace-only lines

      // Combine valid lines into SQL commands and execute them
      val commands = validLines.mkString("\n").split(";").map(_.trim).filter(_.nonEmpty)

      commands.foreach { command =>
        try {
          if (command.toLowerCase.startsWith("insert into")) {
            val tableName = command.split(" ")(2) // Extract table name from the insert statement
            val columns = SqlUtils.getTableColumns(jdbcUrl, jdbcUser, jdbcPassword, jdbcDriver, tableName)
            val commandWithColumns = SqlUtils.processInsertQueries(command, tableName, columns)
            println(s"Executing command: $commandWithColumns")
            statement.execute(commandWithColumns)
            val successMsg = s"[SUCCESS] Executed: $commandWithColumns"
            println(successMsg)
            logBuffer.append(successMsg + "\n")
          } else {
            println(s"Executing command: $command")
            statement.execute(command)
            val successMsg = s"[SUCCESS] Executed: $command"
            println(successMsg)
            logBuffer.append(successMsg + "\n")
          }
        } catch {
          case ex: Exception =>
            val errorMsg = s"[ERROR] Failed to execute: $command\nMessage: ${ex.getMessage}"
            println(errorMsg)
            logBuffer.append(errorMsg + "\n")
        }
      }

      // Save execution log to a file
      println(s"Execution log saved to: $logPath")
      Files.write(Paths.get(logPath), logBuffer.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8))

    } catch {
      case ex: Exception =>
        val fatalErrorMsg = s"[FATAL] Error: ${ex.getMessage}"
        println(fatalErrorMsg)
        logBuffer.append(fatalErrorMsg + "\n")
        Files.write(Paths.get(logPath), logBuffer.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8))
    } finally {
      if (statement != null) statement.close()
      if (connection != null) connection.close()
    }

    // Clean old log files after execution
    cleanOldLogFiles("path/to/logs") // Specify your log directory path
  }

  // Main entry point
  def main(args: Array[String]): Unit = {
    val scriptPath = "path/to/your/sqlfile.sql"
    val jdbcUrl = "jdbc:your_database_url"
    val jdbcUser = "your_database_username"
    val jdbcPassword = "your_database_password"
    val jdbcDriver = "your.jdbc.Driver"

    runSqlScript(scriptPath, jdbcUrl, jdbcUser, jdbcPassword, jdbcDriver)
  }
}
