import java.io._
import java.util.concurrent.locks.ReentrantLock
import java.time.LocalDate

// Define a global lock for file writing
val fileLock = new ReentrantLock()

// Define the CSV file path
val csv2Path = "/your/path/Master_Table1.csv"

// Define the header
val master2_header = "ALERT_ID,SEQUENCENUMBER,VARIABLE,HEADER"

// Function to check if file has a header
def fileHasHeader(filePath: String, header: String): Boolean = {
  val file = new File(filePath)
  if (!file.exists()) return false
  val reader = new BufferedReader(new FileReader(file))
  val firstLine = reader.readLine()
  reader.close()
  firstLine != null && firstLine.contains(header)
}

// Function to safely write to CSV
def writeAlertsToCSV(MasterTable2DF: List[String]): Unit = {
  fileLock.lock() // Acquire lock
  try {
    val outputStream1 = new FileOutputStream(csv2Path, true) // Append mode
    val master_writer2 = new BufferedWriter(new OutputStreamWriter(outputStream1, "UTF-8"))

    val headerPresent1 = fileHasHeader(csv2Path, master2_header)

    if (!headerPresent1) {
      master_writer2.write(master2_header)
      master_writer2.newLine()
    }

    MasterTable2DF.foreach { row =>
      master_writer2.write(row)
      master_writer2.newLine()
    }

    master_writer2.close() // Close writer
  } catch {
    case e: Exception =>
      println(s"âš  Error writing to CSV: ${e.getMessage}") // Log error
  } finally {
    fileLock.unlock() // Release lock
  }
}

// Simulated Data
val MasterTable2DF = List(
  "DC0079,12345,Value1,Header1",
  "DC0019,67890,Value2,Header2"
)

// Call function to write alerts
writeAlertsToCSV(MasterTable2DF)
