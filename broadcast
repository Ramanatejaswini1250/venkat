import java.util.{Calendar, TimeZone}
import java.text.SimpleDateFormat

// Suppose these sets/maps store your success/failed/missed alerts.
val combinedSuccessAlerts: Set[String] = Set("RAO387", "DC0019")
val combinedFailedAlerts: Map[String, String] = Map("XYZ123" -> "Validation error")
val missedAlerts: Set[String] = Set("RAP387")

// 1) Define your target time (16:05) in AEST
val aestZone = TimeZone.getTimeZone("Australia/Sydney")
val calNow = Calendar.getInstance(aestZone)
val currentHour = calNow.get(Calendar.HOUR_OF_DAY)
val currentMin = calNow.get(Calendar.MINUTE)
val currentSec = calNow.get(Calendar.SECOND)

println(f"Current local time in AEST: $currentHour%02d:$currentMin%02d:$currentSec%02d")

// We want 16:05 exactly
val targetHour = 16
val targetMin  = 5

// 2) If it's before 16:05, calculate how long to wait
if (currentHour < targetHour || (currentHour == targetHour && currentMin < targetMin)) {
  // Calculate how many minutes/seconds to wait until 16:05
  val minToWait = (targetHour - currentHour) * 60 + (targetMin - currentMin)
  val secToWait = (60 - currentSec) % 60  // if currentSec=0, no extra seconds
  // Convert total wait time to milliseconds
  val waitMillis = (minToWait * 60 + secToWait) * 1000L

  println(s"Waiting ${waitMillis/1000} seconds until 16:05 AEST...")
  Thread.sleep(waitMillis)

  // Now it's at or very close to 16:05
  sendConsolidatedEmail(combinedSuccessAlerts, combinedFailedAlerts, missedAlerts)

} else if (currentHour == targetHour && currentMin == targetMin) {
  // Already exactly 16:05
  println("It's exactly 16:05 AEST. Sending email now.")
  sendConsolidatedEmail(combinedSuccessAlerts, combinedFailedAlerts, missedAlerts)

} else {
  // It's after 16:05 (or far before 16:00, etc.)
  // Decide if you want to skip or still send.
  println("It's after 16:05 AEST. Skipping or handle differently.")
}

// Example consolidated email function
def sendConsolidatedEmail(
  combinedSuccessAlerts: Set[String],
  combinedFailedAlerts: Map[String, String],
  missedAlerts: Set[String]
): Unit = {
  val currentDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(calNow.getTime)
  // ...build your HTML email body...
  println(s"Sending consolidated email at $currentDate with success=$combinedSuccessAlerts, failed=$combinedFailedAlerts, missed=$missedAlerts")
  // Actually send the email (omitted for brevity)
}


  val missed_Query = s"""
    UPDATE U_D_DSV_001_RIS_1.Ramp_Control_BAU_Jobs_Info 
    SET stakoltus=?, data_load_received=?, data_run_start_time=?, data_run_end_time=? 
    WHERE alert_code IN ($missedAlertsList)
  """
 // Get business and email details from expectedAlerts DF
  val business = df.filter(col("alert_code") === alertCode)
                   .select("business")  
                   .as[String]
                   .collect()
                   .headOption.getOrElse("Unknown")  

  val email = df.filter(col("alert_code") === alertCode)
                .select("email")  
                .as[String]
                .collect()
                .headOption.getOrElse("default@company.com")  

  val message = s"Alert $alertCode was missed and did not arrive as expected."  

// Extract frequency for the given alertCode
val frequency = df.filter(col("alert_code") === alertCode)
                  .select("frequency")
                  .as[String]
                  .collect()
                  .headOption

// If frequency is missing, send an email and throw an exception
frequency match {
  case Some(freq) => 
    println(s"Frequency for alertCode $alertCode: $freq")  // Logging purpose

  case None => 
    sendEmailNotification(alertCode, "Missing frequency", emailAddress, business, "")
    throw new Exception("Missing frequency")
}



  val pstmt1 = pconn.prepareStatement(missed_Query)
  pstmt1.setString(1, "0")
  pstmt1.setString(2, "NA")
  pstmt1.setString(3, "NA")
  pstmt1.setString(4, "NA")
  pstmt1.executeUpdate()
  pstmt1.close()
}
