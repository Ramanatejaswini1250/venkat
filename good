import org.apache.spark.sql.{SparkSession, DataFrame}
import java.io.{BufferedReader, InputStreamReader}

object EmailNotificationApp {
  
  // Define Spark session (initialize the Spark context)
  val spark: SparkSession = SparkSession.builder()
    .appName("EmailNotificationApp")
    .master("local[*]") // Adjust as needed for your environment
    .getOrCreate()
  
  // JDBC connection parameters (to be set with actual values)
  val jdbcUrl: String = "jdbc:your_database_url"
  val jdbcUser: String = "your_user"
  val jdbcPassword: String = "your_password"
  val jdbcDriver: String = "com.jdbc.Driver"  // Specify the correct JDBC driver class

  // Function to send email notifications via a shell script
  def sendEmailNotification(alertCode: String, message: String): Unit = {
    val shellScriptPath = "/path/to/email_notification.sh"  // Update with actual path to script
    val process = new ProcessBuilder("bash", shellScriptPath, alertCode, message).start()

    // Capture the output of the shell script
    val reader = new BufferedReader(new InputStreamReader(process.getInputStream))
    var line: String = null
    while ({line = reader.readLine(); line != null}) {
      println(line)  // You can log this output if necessary
    }

    // Check for process exit code
    val exitCode = process.waitFor()
    if (exitCode != 0) {
      println(s"Error executing shell script: $shellScriptPath with exit code: $exitCode")
    } else {
      println(s"Email notification sent for alertCode: $alertCode with message: $message")
    }
  }

  // Function to run SQL script
  def runSqlScript(scriptPath: String): Unit = {
    // Implement running the SQL script here, e.g., using `spark.sql()` or executing via command line
    println(s"Running SQL script at: $scriptPath")
    // Example:
    // val sqlContent = scala.io.Source.fromFile(scriptPath).getLines().mkString("\n")
    // spark.sql(sqlContent)  // This is just a placeholder
  }

  // Main logic to process the DataFrame and send email notifications
  def processRecords(df: DataFrame): Unit = {
    df.foreachPartition { partition =>
      partition.foreach { row =>
        val alertCode = row.getAs[String]("alert_code")
        val dtCount = row.getAs[Int]("dt_count")
        val dateToLoad = row.getAs[String]("date_to_load")
        val bteqLocation = row.getAs[String]("bteq_location")

        val sourceTableName = row.getAs[String]("source_table_name").getOrElse {
          sendEmailNotification(alertCode, "Missing source_table_name")
          throw new Exception("Missing source_table_name")
        }

        val frequency = row.getAs[String]("frequency").getOrElse {
          sendEmailNotification(alertCode, "Missing frequency")
          throw new Exception("Missing frequency")
        }

        val filterColumn = row.getAs[String]("filter_column").getOrElse {
          sendEmailNotification(alertCode, "Missing filter_column")
          throw new Exception("Missing filter_column")
        }

        try {
          if (dtCount > 0) {
            // Run the query to count rows in the source table with the filter
            val jdbcQuery = s"(SELECT COUNT(*) AS cnt FROM $sourceTableName WHERE $filterColumn = '$dateToLoad') AS subquery"
            val sourceTableCountDF = spark.read
              .format("jdbc")
              .option("url", jdbcUrl)
              .option("dbtable", jdbcQuery)
              .option("user", jdbcUser)
              .option("password", jdbcPassword)
              .option("driver", jdbcDriver)
              .load()

            // Extract the count
            val sourceTableCount = sourceTableCountDF.collect()(0).getAs[Long]("cnt")

            // Compare counts
            if (sourceTableCount == dtCount) {
              val sqlFilePath = s"${bteqLocation}/${alertCode}.sql"
              runSqlScript(sqlFilePath)
              sendEmailNotification(alertCode, "SQL script executed successfully")
            } else {
              val message = s"Source table count ($sourceTableCount) does not match DT_COUNT ($dtCount) for alertCode: $alertCode"
              sendEmailNotification(alertCode, message)
              println(message)
            }
          } else {
            val message = s"DT_COUNT is less than or equal to 0 for alertCode: $alertCode"
            sendEmailNotification(alertCode, message)
            throw new Exception(message)
          }
        } catch {
          case ex: Exception =>
            val message = s"Error processing alertCode: $alertCode - ${ex.getMessage}"
            sendEmailNotification(alertCode, message)
            println(message)
            ex.printStackTrace()
        }
      }
    }
  }

  // Entry point for the Spark job
  def main(args: Array[String]): Unit = {
    // Simulate a DataFrame as an example (replace with actual DataFrame loading)
    val data = Seq(
      ("A001", 10, "2024-12-16", "/path/to/sql", Some("source_table"), Some("daily"), Some("filter_column")),
      ("A002", 5, "2024-12-17", "/path/to/sql", Some("source_table"), Some("hourly"), Some("filter_column"))
    )

    import spark.implicits._
    val df = data.toDF("alert_code", "dt_count", "date_to_load", "bteq_location", "source_table_name", "frequency", "filter_column")

    // Process the records and send notifications
    processRecords(df)

    // Stop the Spark session
    spark.stop()
  }
}
